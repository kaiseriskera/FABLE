configfile: "config/config.yaml"

OPT = config["rule_opt"]
TESTPATH = config["test_path"]
ref_genome = config["reference"]
MM2_BENCH = config["mm2_bench"]
VULCAN_BENCH = config["vulcan_bench"]
SAMPLE = config["samples"]
ALIGNER = config["aligners"]

# create work directory differently according to the rule_opt, i.e. workdir_mm2 or workdir_vulcan.
workdir: config['work_dir_path']+"_"+OPT

# find way to put first4steps, vulcansteps and mm2steps into 3 sep. workdirs
# so no need new data generation for first4 if user specifies mm2 after vulcan and vice versa
import pandas as pd
import csv
import numpy as np
import matplotlib.pyplot as plt

rule all:
    input:
        "report/FastQC/PCNF_read_fastqc.html",
        "report/Pre-alignment_NanoPlot/PCNF_read_NanoPlot-report.html",
        # "report/Post-alignment_NanoPlot/vulcan_PCNF_NanoPlot-report.html",
        # "report/Post-alignment_NanoPlot/mm2_PCNF_NanoPlot-report.html",
        #expand("report/Post-alignment_NanoPlot/{aligner}_PCNF_NanoPlot-report.html", aligner=ALIGNER, allow_missing=True),
        "report/Post-alignment_NanoPlot/Aligned_NanoPlot-report.html",
        "report/Benchmarks/bench.txt",
        "report/Benchmarks/benchfile.txt",
        "report/Samtools_Stats/Aligned_readsamstat.txt",
        #"report/Benchmarks/dfbench.png",
        "report/Benchmarks/benchfile.csv",
        "report/Benchmarks/benchfile2.csv",
        "report/Benchmarks/benchfile1.csv"

rule porechop:
    input: 
        TESTPATH
    output:
        "data/PoreChop/PC_read.fastq.gz"
    params:
        outdir="data/PoreChop"
    benchmark:
        "benchmarks/PoreChop.txt"
    threads: 12
    shell: 
        "porechop -i {input} -t {threads} -o {output}"
        
rule nanofilt:
    input: 
        "data/PoreChop/PC_read.fastq.gz"
    output:
        "data/NanoFilt/PCNF_read.fastq.gz"
    params:
        quality="10",
        headcrop="10",
        outdir="data/NanoFilt"
    benchmark:
        "benchmarks/NanoFilt.txt"
    shell:
        "gunzip -c {input} | NanoFilt -q {params.quality} --headcrop {params.headcrop} | gzip > {output}"

rule fastqc:
    input:
        "data/NanoFilt/PCNF_read.fastq.gz"
    output:
        "report/FastQC/PCNF_read_fastqc.html",
        "report/FastQC/PCNF_read_fastqc.zip"
    threads: 8
    params:
        outdir="report/FastQC"
    benchmark:
        "benchmarks/FastQC.txt"
    shell:
        "fastqc --threads {threads} --outdir {params.outdir} {input}"

rule pre_aln_NanoPlot:
    input:
        "data/NanoFilt/PCNF_read.fastq.gz"
    output:
        "report/Pre-alignment_NanoPlot/PCNF_read_NanoPlot-report.html",
        "report/Pre-alignment_NanoPlot/PCNF_read_NanoStats.txt"
    params:
        prefix="PCNF_read_",
        outdir="report/Pre-alignment_NanoPlot"
    threads: 8 
    benchmark:
        "benchmarks/Pre-alignment_NanoPlot.txt"
    shell:
        "NanoPlot -t {threads} --fastq {input} --outdir {params.outdir} -p {params.prefix}"

if OPT == 'vulcan':
    rule vulcan:
        input:
            ref = ref_genome,
            fastq="data/NanoFilt/PCNF_read.fastq.gz"
        output:
            "data/Vulcan/vulcan_PCNF_90.bam"
        params:
            prefix="data/Vulcan/vulcan_PCNF"
        threads: 10
        benchmark:
            "benchmarks/Vulcan.txt"
        shell:
            "vulcan -ont -t {threads} -r {input.ref} -i {input.fastq} -o {params.prefix}"
    
    rule vulcan_bam_index:
        input:
            "data/Vulcan/vulcan_PCNF_90.bam",
        output:
            "data/Vulcan/vulcan_PCNF_90.bam.bai"
        benchmark:
            "benchmarks/vulcan_bam_index.txt"
        shell:
            "samtools index {input}"

    rule vulcan_NanoPlot:
        input:
            "data/Vulcan/vulcan_PCNF_90.bam"
        output:
            "report/Post-alignment_NanoPlot/vulcan_PCNF_NanoPlot-report.html",
            "report/Post-alignment_NanoPlot/vulcan_PCNF_NanoStats.txt"
        params:
            prefix="vulcan_PCNF_",
            outdir="report/Post-alignment_NanoPlot"
        threads: 8
        benchmark:
            "benchmarks/Post-alignment_NanoPlot.txt"
        shell:
            "NanoPlot -t {threads} --bam {input} -p {params.prefix} -o {params.outdir}"
    
    rule samstats:
        input:  
            "data/Vulcan/vulcan_PCNF_90.bam"
        output:
            "report/Samtools_Stats/vulcan_PCNF_90.txt"
        shell:
            "samtools stats {input} | grep ^SN | cut -f 2- > {output}"
        
    rule vulcan_samstats_final:
        input:
            "report/Samtools_Stats/vulcan_PCNF_90.txt"
        output:
            "report/Samtools_Stats/Aligned_readsamstat.txt"
        shell:
            "mv {input} {output}"
   
    rule vulcan_bench_report:
        input:
            expand("benchmarks/{bench}.txt", bench=VULCAN_BENCH)
            # vulcan_bench: ["PoreChop", "NanoFilt", "FastQC", "Pre-alignment_NanoPlot", "Vulcan", "vulcan_bam_index", "Post-alignment_NanoPlot"]
        output:
            'report/Benchmarks/bench.txt'
        run:
            import os
            with open(output[0], 'w') as out:
                for i in input:
                    bench = i.split('.')[0][11:]
                    for line in open(i): 
                        benchline= bench + " " + line 
                        # header = benchhead + "\n"
                        # out.write(header + benchline)
                        out.write(benchline)
    
    rule vulcan_final_bench:
        input:
            "report/Benchmarks/bench.txt"
        output:
            "report/Benchmarks/benchfile.txt"
        shell:
            # "awk 'NR % 2 == 0' {input} > {output}"
            "sed '/io_out/d' {input} > {output}"

    rule txttocsv:
        input:
            "report/Benchmarks/benchfile.txt"
        output:
            "report/Benchmarks/benchfile.csv"
        run:
            import pandas as pd
            # # benchhead=["sample/process","s","h:m:s","max_rss","max_vms","max_uss","max_pss","io_in","io_out","mean_load","cpu_time"]
            # df = pd.read_csv("report/Benchmarks/bench.txt")
            # df.to_csv("report/Benchmarks/benchfile.csv", index=False)
            with open("report/Benchmarks/benchfile.txt") as f, open("report/Benchmarks/benchfile.csv", 'w', newline='') as o:
                writer = csv.writer(o)
                for line in f:
                    writer.writerow(line.split())
                
    rule header:
        input:
            "report/Benchmarks/benchfile.csv"
        output:
            "report/Benchmarks/benchfile1.csv"
        run:
            from pandas import read_csv 
            df = read_csv("report/Benchmarks/benchfile.csv",header=None)
            df.columns = ["process","s","h:m:s","max_rss","max_vms","max_uss","max_pss","io_in","io_out","mean_load","cpu_time"]
            df.to_csv("report/Benchmarks/benchfile1.csv", index=False)

    rule inversecsv:
        input:
            "report/Benchmarks/benchfile1.csv"
        output:
            "report/Benchmarks/benchfile2.csv"
        run:
            import re
            import csv
            from csv import reader, writer 
            with open("report/Benchmarks/benchfile1.csv") as f, open("report/Benchmarks/benchfile2.csv", 'w', newline='') as fw: 
                writer(fw, delimiter=',').writerows(zip(*reader(f, delimiter=',')))

    rule vulcan_nano_final:
        input:
            "report/Post-alignment_NanoPlot/vulcan_PCNF_NanoPlot-report.html"
        output:
            "report/Post-alignment_NanoPlot/Aligned_NanoPlot-report.html"
        shell:
            "mv {input} {output}"

else:
    rule minimap2:
        input:
            ref = ref_genome,
            fastq="data/NanoFilt/PCNF_read.fastq.gz"
        output:
            "data/Minimap2/mm2_PCNF.sam"
        benchmark:
            "benchmarks/Minimap2.txt"
        shell:
            "minimap2 -ax map-ont {input.ref} {input.fastq} > {output}"

    rule sam_to_bam:
        input:
            "data/Minimap2/mm2_PCNF.sam"
        output:
            "data/Minimap2/mm2_PCNF.bam"
        benchmark:
            "benchmarks/mm2_sam_to_bam.txt"
        shell:
            "samtools sort {input} -o {output}"
            
    rule mm2_bam_index:
        input:
            "data/Minimap2/mm2_PCNF.bam"
        output:
            "data/Minimap2/mm2_PCNF.bam.bai"
        benchmark:
            "benchmarks/mm2_bam_index.txt"
        shell:
            "samtools index {input}"

    rule mm2_NanoPlot:
        input:
            "data/Minimap2/mm2_PCNF.bam"
        output:
            "report/Post-alignment_NanoPlot/mm2_PCNF_NanoPlot-report.html",
            "report/Post-alignment_NanoPlot/mm2_PCNF_NanoStats.txt"
        params:
            prefix="mm2_PCNF_",
            outdir="report/Post-alignment_NanoPlot/"
        threads: 8
        benchmark:
            "benchmarks/Post-alignment_NanoPlot.txt"
        shell:
            "NanoPlot -t {threads} --bam {input} -p {params.prefix} -o {params.outdir}"
    
    rule samstats:
        input:  
            "data/Minimap2/mm2_PCNF.bam"
        output:
            "report/Samtools_Stats/mm2_PCNF.txt"
        shell:
            "samtools stats {input} | grep ^SN | cut -f 2- > {output}"

    rule vulcan_samstats_final:
        input:
            "report/Samtools_Stats/mm2_PCNF.txt"
        output:
            "report/Samtools_Stats/Aligned_readsamstat.txt"
        shell:
            "mv {input} {output}"
     
    # benchhead= "sample/process  s  h:m:s  max_rss  max_vms  max_uss  max_pss  io_in  io_out  mean_load  cpu_time"
    
    rule mm2_bench_report:
        input:
            expand("benchmarks/{bench}.txt", bench=MM2_BENCH)
        output:
            'report/Benchmarks/bench.txt'
        run:
            import os
            with open(output[0], 'w') as out:
                for i in input:
                    # bench = (config["samples"])+i.split('.')[0][10:]
                    bench = i.split('.')[0][11:]
                    for line in open(i):
                        benchline= bench + " " + line 
                        # header = benchhead + "\n"
                        # out.write(header + benchline)
                        out.write(benchline)
     
    #  remove alt. lines
    rule mm2_final_bench:
        input:
            'report/Benchmarks/bench.txt'
        output:
            "report/Benchmarks/benchfile.txt"
        shell:
            # "awk 'NR == 1 || NR % 4 == 0' {input} > {output}" (alternative way)
            # "sed -n '1~2!p' {input} > {output}"
            "sed '/io_out/d' {input} > {output}"
            # import pandas as pd
            # df = pd.read_fwf('report/Benchmarks/bench.txt')
            # df.to_csv("report/Benchmarks/benchfile.csv", index=False)
            
    rule txttocsv:
        input:
            "report/Benchmarks/benchfile.txt"
        output:
            "report/Benchmarks/benchfile.csv"
        run:
            import pandas as pd
            # # benchhead=["sample/process","s","h:m:s","max_rss","max_vms","max_uss","max_pss","io_in","io_out","mean_load","cpu_time"]
            # df = pd.read_csv("report/Benchmarks/bench.txt")
            # df.to_csv("report/Benchmarks/benchfile.csv", index=False)
            with open("report/Benchmarks/benchfile.txt") as f, open("report/Benchmarks/benchfile.csv", 'w', newline='') as o:
                writer = csv.writer(o)
                for line in f:
                    writer.writerow(line.split())
                
    rule header:
        input:
            "report/Benchmarks/benchfile.csv"
        output:
            "report/Benchmarks/benchfile1.csv"
        run:
            from pandas import read_csv 
            df = read_csv("report/Benchmarks/benchfile.csv",header=None)
            df.columns = ["process","s","h:m:s","max_rss","max_vms","max_uss","max_pss","io_in","io_out","mean_load","cpu_time"]
            df.to_csv("report/Benchmarks/benchfile1.csv", index=False)

    rule inversecsv:
        input:
            "report/Benchmarks/benchfile1.csv"
        output:
            "report/Benchmarks/benchfile2.csv"
        run:
            import re
            import csv
            from csv import reader, writer 
            with open("report/Benchmarks/benchfile1.csv") as f, open("report/Benchmarks/benchfile2.csv", 'w', newline='') as fw: 
                writer(fw, delimiter=',').writerows(zip(*reader(f, delimiter=',')))

    # plot bar chart
    rule barchart:
        input: 
            "report/Benchmarks/benchfile2.csv"
        output:
            "report/Benchmarks/dfbench.png"
        script:
            "scripts/plot_benchmark.py"


# #     # # # rule benchcsv:
# #     # # #     input:
# #     # # #         "report/Benchmarks/bench.csv"
# #     # # #     output:
# #     # # #         "report/Benchmarks/benchd.csv"
# #     # # #     run:
# #     # # #         benchdata = pd.read_csv("report/Benchmarks/bench.csv")
# #     # # #         svalues=benchdata["s"].values
# #     # # #         hms=benchdata["h:m:s"].values
# #     # # #         max_rss=benchdata["max_rss"].values
# #     # # #         max_vms=benchdata["max_vms"].values
# #     # # #         max_uss=benchdata["max_uss"].values  
# #     # # #         max_pss = benchdata["max_pss"].values
# #     # # #         io_in = benchdata["io_in"].values
# #     # #         io_out = benchdata["io_out"].values
# #     # #         mean_load = benchdata["mean_load"].values
# #     # #         cpu_time = benchdata["cpu_time"].values
# #     # #         data = np.array(svalues, hms, max_rss, max_uss, max_pss, io_in, io_out,mean_load,cpu_time)
# #     # #         # x = np.arange(data.shape[0])
# #     # #         # dx = (np.arange(data.shape[1])-data.shape[1]/2.)/(data.shape[1]+2.)
# #     # #         # d = 1./(data.shape[1]+2.)
# #     # #         # fig, ax=plt.subplots()
# #     # #         # for i in range(data.shape[1]):
# #     # #         #     ax.bar(x+dx[i],data[:,i], width=d, label="label {}".format(i))
# #     # #         # plt.legend(framealpha=1).draggable()
# #     # #         # plt.show()
# #     # #         # svalues=benchdata[:,0]
# #     # #         # hmsvalues=benchdata[:,1]
# #     # #         # maxrss=benchdata[:,2]
# #     #         # maxuss=benchdata[:,3]
# #     #         # maxpss=benchdata[:,4]
# #     #         # ioin=benchdata[:,5]
# #             # ioout=benchdata[:,6]
# #             # meanload=benchdata[:,7]
# #             # cputime=benchdata[:,8]
            

# #     #To dos: workaround to simplify the command line input to snakemake
    rule mm2_nano_final:
        input:
            "report/Post-alignment_NanoPlot/mm2_PCNF_NanoPlot-report.html"
        output:
            "report/Post-alignment_NanoPlot/Aligned_NanoPlot-report.html"
        shell:
            "mv {input} {output}"

# # # # # ======== End of Else Statement for mm2/vulcan option ====================================================