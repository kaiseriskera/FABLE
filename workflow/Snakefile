configfile: "config/config.yaml"

OPT = config["rule_opt"]
TESTPATH = config["test_path"]
ref_genome = config["reference"]
MM2_BENCH = config["mm2_bench"]
VULCAN_BENCH = config["vulcan_bench"]
SAMPLE = config["samples"]
ALIGNER = config["aligners"]

#workdir: config['test_dir2']
# find way to put first4steps, vulcansteps and mm2steps into 3 sep. workdirs
# so no need new data generation for first4 if user specifies mm2 after vulcan and vice versa

rule all:
    input:
        "report/FastQC/PCNF_read_fastqc.html",
        "report/Pre-alignment_NanoPlot/PCNF_read_NanoPlot-report.html",
        # "report/Post-alignment_NanoPlot/vulcan_PCNF_NanoPlot-report.html",
        # "report/Post-alignment_NanoPlot/mm2_PCNF_NanoPlot-report.html",
        #expand("report/Post-alignment_NanoPlot/{aligner}_PCNF_NanoPlot-report.html", aligner=ALIGNER, allow_missing=True),
        "report/Post-alignment_NanoPlot/Aligned_NanoPlot-report.html",
        "report/Benchmarks/bench.txt",
        "report/Samtools_Stats/Aligned_readsamstat.txt",
        "report/Benchmarks/benchfile.txt"

rule porechop:
    input: 
        TESTPATH
    output:
        "data/PoreChop/PC_read.fastq.gz"
    params:
        outdir="data/PoreChop"
    benchmark:
        "benchmarks/PoreChop.txt"
    threads: 12
    shell: 
        "porechop -i {input} -t {threads} -o {output}"
        
rule nanofilt:
    input: 
        "data/PoreChop/PC_read.fastq.gz"
    output:
        "data/NanoFilt/PCNF_read.fastq.gz"
    params:
        quality="10",
        headcrop="10",
        outdir="data/NanoFilt"
    benchmark:
        "benchmarks/NanoFilt.txt"
    shell:
        "gunzip -c {input} | NanoFilt -q {params.quality} --headcrop {params.headcrop} | gzip > {output}"

rule fastqc:
    input:
        "data/NanoFilt/PCNF_read.fastq.gz"
    output:
        "report/FastQC/PCNF_read_fastqc.html",
        "report/FastQC/PCNF_read_fastqc.zip"
    threads: 8
    params:
        outdir="report/FastQC"
    benchmark:
        "benchmarks/FastQC.txt"
    shell:
        "fastqc --threads {threads} --outdir {params.outdir} {input}"

rule pre_aln_NanoPlot:
    input:
        "data/NanoFilt/PCNF_read.fastq.gz"
    output:
        "report/Pre-alignment_NanoPlot/PCNF_read_NanoPlot-report.html",
        "report/Pre-alignment_NanoPlot/PCNF_read_NanoStats.txt"
    params:
        prefix="PCNF_read_",
        outdir="report/Pre-alignment_NanoPlot"
    threads: 8 
    benchmark:
        "benchmarks/Pre-alignment_NanoPlot.txt"
    shell:
        "NanoPlot -t {threads} --fastq {input} --outdir {params.outdir} -p {params.prefix}"

if OPT == 'vulcan':
    rule vulcan:
        input:
            ref = ref_genome,
            fastq="data/NanoFilt/PCNF_read.fastq.gz"
        output:
            "data/Vulcan/vulcan_PCNF_90.bam"
        params:
            prefix="data/Vulcan/vulcan_PCNF"
        threads: 10
        benchmark:
            "benchmarks/Vulcan.txt"
        shell:
            "vulcan -ont -t {threads} -r {input.ref} -i {input.fastq} -o {params.prefix}"
    
    rule vulcan_bam_index:
        input:
            "data/Vulcan/vulcan_PCNF_90.bam",
        output:
            "data/Vulcan/vulcan_PCNF_90.bam.bai"
        benchmark:
            "benchmarks/vulcan_bam_index.txt"
        shell:
            "samtools index {input}"

    rule vulcan_NanoPlot:
        input:
            "data/Vulcan/vulcan_PCNF_90.bam"
        output:
            "report/Post-alignment_NanoPlot/vulcan_PCNF_NanoPlot-report.html",
            "report/Post-alignment_NanoPlot/vulcan_PCNF_NanoStats.txt"
        params:
            prefix="vulcan_PCNF_",
            outdir="report/Post-alignment_NanoPlot"
        threads: 8
        benchmark:
            "benchmarks/Post-alignment_NanoPlot.txt"
        shell:
            "NanoPlot -t {threads} --bam {input} -p {params.prefix} -o {params.outdir}"
    
    rule samstats:
        input:  
            "data/Vulcan/vulcan_PCNF_90.bam"
        output:
            "report/Samtools_Stats/vulcan_PCNF_90.txt"
        shell:
            "samtools stats {input} | grep ^SN | cut -f 2- > {output}"
        
    rule vulcan_samstats_final:
        input:
            "report/Samtools_Stats/vulcan_PCNF_90.txt"
        output:
            "report/Samtools_Stats/Aligned_readsamstat.txt"
        shell:
            "mv {input} {output}"

    benchhead= "sample/process  s  h:m:s  max_rss  max_vms  max_uss  max_pss  io_in  io_out  mean_load  cpu_time"
    
    rule vulcan_bench_report:
        input:
            expand("benchmarks/{bench}.txt", bench=VULCAN_BENCH)
        output:
            'report/Benchmarks/bench.txt'
        run:
            with open(output[0], 'w') as out:
                for i in input:
                    bench = (config["samples"])+i.split('.')[0][10:]
                    for line in open(i):
                        benchline= bench + ' ' + line 
                        header = benchhead + "\n"
                        # header = (config["benchhead1"])
                        out.write(header + benchline)
                        # out.write(benchline)
    
    rule vulcan_final_bench:
        input:
            'report/Benchmarks/bench.txt'
        output:
            "report/Benchmarks/benchfile.txt"
        shell:
            # "awk 'NR == 1 || NR % 4 == 0' {input} > {output}" (alternative way)
            "sed -n '1p;0~4p' {input} > {output}"

    # rule vbenchcsv:
    #     input:
    #         "report/Benchmarks/benchfile.txt"
    #     output:
    #         "report/Benchmarks/benchfile2.txt"
    #     run:
    #         import pandas as pd
    #         df = pd.read_csv("report/Benchmarks/benchfile.txt", sep='\t')
    #         header = config["samples"]+config["benchhead"]
    #         frame=pd.DataFrame(df.values, columns = str(header))
    #         frame.to_csv("report/Benchmarks/benchfile.txt", sep='\t')
    
    rule vulcan_nano_final:
        input:
            "report/Post-alignment_NanoPlot/vulcan_PCNF_NanoPlot-report.html"
        output:
            "report/Post-alignment_NanoPlot/Aligned_NanoPlot-report.html"
        shell:
            "mv {input} {output}"

else:
    rule minimap2:
        input:
            ref = ref_genome,
            fastq="data/NanoFilt/PCNF_read.fastq.gz"
        output:
            "data/Minimap2/mm2_PCNF.sam"
        benchmark:
            "benchmarks/Minimap2.txt"
        shell:
            "minimap2 -ax map-ont {input.ref} {input.fastq} > {output}"

    rule sam_to_bam:
        input:
            "data/Minimap2/mm2_PCNF.sam"
        output:
            "data/Minimap2/mm2_PCNF.bam"
        benchmark:
            "benchmarks/mm2_sam_to_bam.txt"
        shell:
            "samtools sort {input} -o {output}"
            
    rule mm2_bam_index:
        input:
            "data/Minimap2/mm2_PCNF.bam"
        output:
            "data/Minimap2/mm2_PCNF.bam.bai"
        benchmark:
            "benchmarks/mm2_bam_index.txt"
        shell:
            "samtools index {input}"

    rule mm2_NanoPlot:
        input:
            "data/Minimap2/mm2_PCNF.bam"
        output:
            "report/Post-alignment_NanoPlot/mm2_PCNF_NanoPlot-report.html",
            "report/Post-alignment_NanoPlot/mm2_PCNF_NanoStats.txt"
        params:
            prefix="mm2_PCNF_",
            outdir="report/Post-alignment_NanoPlot/"
        threads: 8
        benchmark:
            "benchmarks/Post-alignment_NanoPlot.txt"
        shell:
            "NanoPlot -t {threads} --bam {input} -p {params.prefix} -o {params.outdir}"
    
    rule samstats:
        input:  
            "data/Minimap2/mm2_PCNF.bam"
        output:
            "report/Samtools_Stats/mm2_PCNF.txt"
        shell:
            "samtools stats {input} | grep ^SN | cut -f 2- > {output}"

    rule vulcan_samstats_final:
        input:
            "report/Samtools_Stats/mm2_PCNF.txt"
        output:
            "report/Samtools_Stats/Aligned_readsamstat.txt"
        shell:
            "mv {input} {output}"
     
    benchhead= "sample/process  s  h:m:s  max_rss  max_vms  max_uss  max_pss  io_in  io_out  mean_load  cpu_time"
    
    rule mm2_bench_report:
        input:
            expand("benchmarks/{bench}.txt", bench=MM2_BENCH)
        output:
            'report/Benchmarks/bench.txt'
        run:
            with open(output[0], 'w') as out:
                for i in input:
                    bench = (config["samples"])+i.split('.')[0][10:]
                    #bench = i.split('.')[0][11:]
                    for line in open(i):
                        #out.write(bench + ' '+ line)
                        benchline= bench + ' ' + line 
                        header = benchhead + "\n"
                        # header = (config["benchhead1"])
                        out.write(header + benchline)
                        # out.write(benchline)

    rule mm2_final_bench:
        input:
            'report/Benchmarks/bench.txt'
        output:
            "report/Benchmarks/benchfile.txt"
        shell:
            # "awk 'NR == 1 || NR % 4 == 0' {input} > {output}" (alternative way)
            "sed -n '1p;0~4p' {input} > {output}"

    # plot histogram
    # # rule benchcsv:
    #     input:
    #         "report/Benchmarks/benchfile.txt"
    #     output:
    #         "report/Benchmarks/benchfile2.txt"
    #     run:
    #         import pandas as pd
    #         df = pd.read_csv("report/Benchmarks/benchfile.txt", sep='\t')
    #         frame=pd.DataFrame(df.values, columns = config["samples"]+config["benchhead"])
    #         frame.to_csv("report/Benchmarks/benchfile.txt", sep='\t')

#     #To dos: workaround to simplify the command line input to snakemake
    rule mm2_nano_final:
        input:
            "report/Post-alignment_NanoPlot/mm2_PCNF_NanoPlot-report.html"
        output:
            "report/Post-alignment_NanoPlot/Aligned_NanoPlot-report.html"
        shell:
            "mv {input} {output}"

# # # ======== End of Else Statement for mm2/vulcan option ====================================================